import{_ as a,o as e,c as o,O as t}from"./chunks/framework.9482e208.js";const f=JSON.parse('{"title":"howitworks","description":"","frontmatter":{},"headers":[],"relativePath":"howitworks/index.md","filePath":"howitworks/index.md"}'),r={name:"howitworks/index.md"},i=t('<h1 id="howitworks" tabindex="-1">howitworks <a class="header-anchor" href="#howitworks" aria-label="Permalink to &quot;howitworks&quot;">​</a></h1><h2 id="为甚需要了解sd是如何工作的" tabindex="-1">为甚需要了解SD是如何工作的？ <a class="header-anchor" href="#为甚需要了解sd是如何工作的" aria-label="Permalink to &quot;为甚需要了解SD是如何工作的？&quot;">​</a></h2><p>强化对SD出图的预测能力，减少资源浪费。</p><p>简单说就是，在脑子里建立一个符合实际的SD模型。</p><p>对于基础功能，参数是有限的，我们可以通过“跑图”测试来理解各种参数对图片生成的影响。但是需要达到对图像的精细控制，我们涉及的参数会越来越多，这个时候我们希望知道什么情况下什么参数是要效果的、哪些是没效果的，我们不希望通过盲目地“跑图”测试去得到我们的图片，这种方式是缺乏“控制”的，一方面这样“跑图”缺少可重复性，另一方面大量“跑图”是一种环境污染。</p><p>问题的复杂度取决于抽象的质量。如果我们知道SD背后的运行原理，我们会知道，例如说，在文生图的时候，controlnet到底参与了多少，在图生图的时候denosing的影响更大还是CW影响更大，我们不希望盲目地乱尝试。而是在脑子里建立一个恰当的SD模型，强化我们对生成结果的控制力。避免环境污染。</p><p>我们希望，SD生成图片是一套漂亮的工业化流程，把我们脑子里的想法最大效率的转化实际的图片。</p><h1 id="如何理解sd的工作方式" tabindex="-1">如何理解SD的工作方式 <a class="header-anchor" href="#如何理解sd的工作方式" aria-label="Permalink to &quot;如何理解SD的工作方式&quot;">​</a></h1><p>理解SD的最佳方式就是亲自动手实现一个SD。</p><p>联想到一本书，how tomcat works。本文会参考这本书对SD如何工作进行解释。争取看完这个教程人人都可以动手实现一个SD。</p><h1 id="sd-ui和sd" tabindex="-1">SD_UI和SD <a class="header-anchor" href="#sd-ui和sd" aria-label="Permalink to &quot;SD_UI和SD&quot;">​</a></h1><p>首先我们要理解，我们经常使用的SD_UI，例如xx，实际上是一个集成的工作环境，我们通常说的用户界面，可以理解为一个壳子，外壳，我们实际的SD图片生成程序运行在一个服务器上。而我们使用SD的方式，一是可以通过编程方式，一种是间接的借助集成环境使用它，通过后者用它时，其实我们收到了一定的约束。一个UI界面即可以很简单，例如只有一个文生图的界面，另一个可以复杂的插件。构建一个复杂集成环境并不容易。但是我们这边为了便于理解。我们将构建一个功能单一的UI界面（文生图），我们更专注于以编程方式控制SD，以便获取它的全部性能。</p><p>本文不会拘泥于技术体系或者最佳实践，而是编程实现一个最小可用的例子。</p><h1 id="real-stable-diffusion" tabindex="-1">real Stable Diffusion <a class="header-anchor" href="#real-stable-diffusion" aria-label="Permalink to &quot;real Stable Diffusion&quot;">​</a></h1><p>先看下AUTOMATIC1111开发的webui A browser interface <code>based on Gradio library</code> for Stable Diffusion.</p><p>我们再看这个Gradio library是什么东西 Gradio is the fastest way to demo your machine learning model with a friendly web interface so that anyone can use it, anywhere!</p>',16),s=[i];function n(d,h,l,c,p,_){return e(),o("div",null,s)}const D=a(r,[["render",n]]);export{f as __pageData,D as default};
